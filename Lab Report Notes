- started 2018-09-16 by pulling TheProject starting point from GitHub.
- made basic UML diagram of what is given
- began planning out the project in the UML diagram
	- keep it simple: only squash for now
	- required a bit of work to get into the "builder" pattern. difficult to understand
	- also, a very complicated diagram. Made sure to use the correct arrows using UMLet.
	- more specific variables and methods are added during coding. Enjoy the dynamic of actually doing things
	- added a game class as an interactive component, as well as a few models with views and controllers
	- game window is where the game actually takes place. May be useful to separate between actual window, because ball depot could be e.g. at the right side 
- continued on to define some things in the TheApp class
	- set size to 16:9 relation
	- changed mouseClicked to keyPressed, since I prefer keyboard controls
	- turns out to be very simple to finish, since all of the logic is in other classes
- next: interactive component builder
	- create game class with its planned methods first
	- game will also need access to PApplet to process input. Makes no sense to do that at TheApp class
	- actually, next steps are very simple. Just call given build methods of game class
	- String type parameter in builder confused me. I decided to settle for a constant instead that allows choosing the type. hex-Number is more or less random
	- PROBLEM: variables declared in a switch case statement, or even in an if are obviously local. 
		- thus, it can't be returned later on after exiting the switch-case statement.
		- required to declare variable outside, but at that point the type is unknown
		- therefore, use abstract class InteractiveComponent. But this lacks the methods, which leads to failure when putting a game into the variable
		- SOLUTION: edit abstract class to force every descendant to have these methods
- continue by implementing game class
	- many other classes from the model, view and controller have to be defined now. So that's what I do
	- decided that floats in models are unnecessary. ints are precise enough for this coordinate system
	- had to change a few variables along the way. as obvious, planning is not my thing. For instance, decided to add stepWidth variable for Paddle controllers
	- finally able to implement build methods.
	- decided to put constants at beginning to ease changing things and increase readability
	- unfortunately, integers may cause imprecision of one pixel at a time. maybe change back to floats later on.
- next up, want to see something!!! began with game window
	- Found that name isn't very fitting so, changed it to game field instead
	- also changed way coordinates and widths are taken. After all, bottom "death" part is still part of field. Use distance top and width instead
	- no output at that point. Figure I have to implement other methods first, so I did
	- did ball and paddle. seemed very easy.
	- fixed an error in which I forgot to pass display into Game constructor. Game needs the display for drawing, building and calculating.
- proceeded by adding input logic to Game class. Depending on which button pressed, call controllers
- now implement controllers
	- paddle controller strategy left, constructor to build actual controllers required
	- now, there was a problem. Needed to determine which controller to choose: controller move, or controller boundary.
	- controller strategies don't know the GameField, though.
	- decided to give paddle an additional attribute: boundaryLeft and boundaryRight. The x coordinates which it may not move past.
	- I found that constantly updating the UML diagram was getting too annoying and was not worth it. Therefore, didn't work on it anymore
	- implementing controllers was again very easy due to the modularity. 
	- Though I had to decide on controller boundary snapping the paddle to either side, depending on its current position
	- paddle now able to move within bounds of game window, as schematic shows. Half a paddle at a time.
- time to implement ball logic
	- noticed I need much more information in the ball controller than originally thought
	- not just ball, but also paddle and gamefield. In fact, every object the ball might collide with
	- also, had to add "ballDeathLine" to gameField, so ballcontroller knows when ball is supposed to die
	- also added convenience functions in GameField to determine boundary
	- proceeded to write logic. 
	- Also added bounceX and bounceY to Ball model. Important: I made sure that ball doesn't boucne immediately, since that'd be a problem with velocity greater than 1.
	- realize that implementation may cause trouble when bouncing in corner; and it doesn't bounce off side of paddle, only top. But let's see.
	- in order to make ball update every time a screen is drawn, had to hook it into InteractiveComponent.update()
	- so I don't have to re-type what was already inside there because i had to override in Game, I decided to rename given update method to updateViews
	- that's then called in the actual update() method. can easily override and extend now
- unfortunately, ball moved only few times, then ran into an error
	- turned out to be a simple mistake on my side. Used getX when it should have been getY.
	- but paddle collision causes an exception, which I've implemented into bounceY and bounceX (fortunately)
	- again, an arithmetic mistake made by me
	- same for the bouncing off walls (negative velocities weren't considered)
	- but finally, it worked very well
- now I decided to make the ball faster every ten seconds
	- made ballcontroller know how high the frame rate is
	- added counter; whenever it is equal to frame rate, one second has passed. 10 seconds means reset counter and increase velocity by 1
	
	
	